"""
Задание 1.
Реализуйте свои пользовательские функции, в которых реализуйте:
a) заполнение списка и словаря программно,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!
"""
from time import time


def time_meter(func):
    def wrapper(*args):
        start_time = time()
        obj = func(*args)
        print(f"Время выполнения {func.__name__} равно {time() - start_time} секунд.")
        return obj
    return wrapper


@time_meter
def gen(name):
    if name == "Словарь":
        return {i: i**2 for i in range(1, 20_000_001)}
    if name == "Список":
        return [i**2 for i in range(1, 20_000_001)]
    else:
        return None


print("ЗАПОЛНЯЕМ.")
my_list = gen("Список")
my_dict = gen("Словарь")

"""
Вывод по скорости заполнения:
В моем случае словарь заполняется в полтора раза медленнее.
Я думаю потому что всё что выполняется для списка это сначала высчитывается
i**2, а затем добавляется в список list.append(i**2) - О(1).
А для словаря.
Сначала создается хеш i(что занимает дополнительное время)
который используется в качестве ключа, 
потом рассчитывается начение i**2
и помещается в хеш таблицу по созданному ключу - О(1).
"""


@time_meter
def reader(obj):
    """выводить никуда не будем, наша цель не в этом"""
    if type(obj) == dict:
        for key in obj:
            n = obj[key]
    if type(obj) == list:
        for i in range(len(obj)):
            n = obj[i]
    else:
        return None


print("Посчитываем значения.")
reader(my_list)
reader(my_dict)

"""
Время выполнения практически одинаковое, так как и взятие значения по ключу из словаря
и взятие элемента по индексу из спсика имеют констатное время выполнения.
"""


@time_meter
def destruction(obj):
    """поудаляем эллементы"""
    if type(obj) == dict:
        for key in list(obj):
            del obj[key]
    if type(obj) == list:
        for i in range(len(obj) - 1, -1):
            del obj[i]
    else:
        return None


print("Поудаляем эллементы")
destruction(my_list)
destruction(my_dict)

"""
А вот операция удаления со словарями оказалась в 10ки раз быстрее, т.к.
время удаления эллемента из списка по индексу линенйное,
а время удаления значения из словаря по ключу константное.
"""
